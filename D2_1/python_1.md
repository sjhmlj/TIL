# 파이썬 기초

- 컴퓨터 : caulculation + remember

- 프로그래밍 : 명령어의 모음

- 언어 : 자신의 생각을 나타내고 전달하기 위해 사용하는 체계. 문법적으로 맞는 말의 집합.    

  

- 선언적 지식(declarative knowledge) : 사실에 대한 내용

- 명령적 지식(imperative knowledge) : How-To  -> 이 명령을 명확하게 하는게 중요하다!    

## 파이썬

- 배우기 쉽다. 다른 프로그래밍 언어에 비해 문법이 간단하다. 
- 크로스 플랫폼 언어
- 인터프리터 언어
- 객체 지향 프로그래밍(object oriented programming) 
  - Object : Any data wit state(attributes or value) and defined behavior(methods). 
  - 여러 속성과 행동을 가지고 있는 데이터이다. 예를 들어 문자 'a' 에 파이썬은 'a'.join, 'a'.upper 등 많은 속성과 행동을 넣는다. 'a'를 단순히 문자로 표현하는데서 끝나는게 아니라 'a' 자체를 객체로 만들고 그 속에 다양한 속성과 행동을 넣어두는 것이다. 

## 기초 문법

- 코드 스타일 가이드
  - 코드를 '어떻게 작성할지'에 대한 가이드 라인 
  - 파이썬에서 제안하는 스타일 가이드 [PEP8](https://peps.python.org/pep-0008/)
  - 기업, 오픈소스 등에서 사용되는 스타일 가이드 [Google  Style guide](https://google.github.io/styleguide/pyguide.html)
  - Space sensitive - 들여쓰기(identation)를 할 때는 스페이스 4번 또는 탭 1번을 입력하는데 한 코드 안에서는 한 종류의 들여쓰기만 사용할 것!
- 코드는 위에서부터 아래로 실행. 

### 1. 변수

- 컴퓨터 메모리 어딘가에 저장되어 있는 객체를 참조하기 위해 사용되는 이름
  - 객체 : 숫자, 문자, 클래스 등 값을 가지고 있는 모든 것 -> 파이썬은 객체지향 언어이며, 모든 것이 객체로 되어 있음. 
- 동일 변수에 다른 객체를 언제든 할당할 수 있기 때문에, 즉, 참조하는 객체가 바뀔 수 있기 때문에 '변수'라고 불림.
- 변수는 할당 연산자(=)를 통해 값을 할당.
  - type() : 변수에 할당된 값의 타입
  - id() : 변수에 할당된 값(객체)의 고유한 아이덴티티 값이며, 메모리주소.

### 2. 식별자(IDenfifiers) 

- 파이썬 객체를 식별하는데 사용하는 이름

- 규칙

  - 식별자의 이름은 영문 알파벳, 언더스코어(_), 숫자로 구성

  - 첫 글자에 숫자가 올 수 없음

  - 길이제한이 없고, 대소문자를 구별

  - 예약어는 사용할 수 없음(False, None, True, and, as, not, ...). 

    ```python
    import keyword
    print(keyword.kwlist)
    ```

  - 내장함수나 모듈 등의 이름으로도 만들면 안됨 

    ```python
    print = 'hi' # XXXX
    ```

### etc

- input([prompt])
  - 사용자로부터 값을 즉시 입력 받을 수 있는 내장함수
  - 반환값은 항상 문자열의 형태로 변환
- 주석
  - 컴퓨터는 주석을 인식하지 않음.
  - 코드에 대한 설명
  - 주석은 코드 실행에 영향을 미치지 않는다. 프로그램의 속도를 느리게 하지 않으며, 용량을 늘리지 않음.

### 3. 자료형

#### 3.1 Boolean Type 
- True, False. 
- 비교/논리 연산을 위해 수행됨
  - 논리 연산자 : and, or, not

- 모든 객체는 bool클래스를 통해 형변환이 될 때, int와 float은 숫자 0을 의미하는 객체, 그리고 문자열은 비어있는 문자('')는 False로 변환된다. 그 외의 것들은 다 True로 반환된다. 

#### 3.2 Numeric Type 
  - Int : 정수 타입. 
    - 매우 큰 수를 나타낼 때 오버플로우가 발생하지 않음. # 오버플로우 : 데이터 타입별로 사용할 수 있는 메모리의 크기를 넘어서는 상황
    - Arbitrary precision arithmetic을 통해 고정된 형태의 메모리가 아닌 가용 메모리들을 활용하여 모든 수 표현에 활용
  - Float : 실수 타입. floating point rounding error이 연산 중 발생 가능. 
  - complex : 복소수

#### 3.3 String Type
- 모든 문자는 str 타입

- ('), (")를 활용하여 표기

- 문자열 연산자
  - 인덱싱 ex) `s[1]`, 

  - 슬라이싱 ex) `s[1:3:1], s[5:2:-1], s[::]`

  - 결합 `+`, 반복 `*`, 포함 ` 'a' in 'apple'`

    ```python
    >>> 'abc' + 'def'
    'abcdef'
    >>> 'a' * 3
    'aaa'
    ```

  - 문자열 내에서 특정 문자나 조작을 윙해서 역슬래시(\\)를 활용하여 구분 

    `\n, \t, \r, \0, \\, \', \"` 

- 문자열 활용
  f-string  

  ```python
  name = 'Seo'
  score = 4.3  
  print(f 'Hello, {name}! you got {score}')```
  # Hello, Seo! you got 4.3
  ```

- 문자열 특징
  - Immutable : 변경 불가능함
  - Iterable : 반복 가능함
- str타입인 길이가 1인 문자 객체는 고유한 숫자로 표현될 수 있다. 이는 ascii code 표를 따른다. 

  ```python
  ord('a')   #97
  ord('1')   #49
  chr(49)    #'1'
  chr(97)    #'a'
  ```

  

#### 3.4 None 
  - 값이 없음을 표현하기 위해서 씀
  - 일반적으로 반환 값이 없는 함수에서 사용하기도 함
### 4. 연산자
- 산술 연산자
  
  `+, -, *, %, /, //, **`
  
- 비교 연산자
  `<, <=, >, >=, ==, !=`
  
  - 비교 연산자의 결과는 `bool`타입이다. 
  
    ```python
    >>> 1 == 1
    True
    >>> 1 == 1.0           ## 다른 타입인 경우에도 같다라고 인식 가능한 경우 True를 반환함.
    True
    >>> 1 == '1'
    False
    ```
  
  - `is`  is 연산의 경우 두개의 객체가 완전히 동일한 것인지 확인한다. 기본적으로 is 연산자는 객체 고유한 id 번호를 확인한다.  동일한 객체라면 같은 메모리 주소를 가진다. 같은 메모리 주소를 가진다면, 동일한 객체이다.
  
    ```python
    >>> 1 == 1.0
    True
    >>> 1 is 1.0
    False
    ```
  
  - 문자열도 대소비교를 할 수 있다. 이 경우 ascii 숫자로 변환되어서 맨 앞부터 비교한다.
  
    ```python
    >>> 'ab' < 'zb'
    True
    >>> ord('a')
    97
    >>> ord('z')
    122
    ```
  
    
  
- and, or 연산

  - `A and B` 연산자 앞 뒤에 객체(혹은 결과가 객체인 연산)가 참인 경우에만 참을 리턴한다.

    A, B는 표현식으로 객체 자체일수도, 연산일수도, 함수일 수도 있다.

    ```python
    >>> (1-1) and True    # False 객체가 생성되서 나오는게 아니라, 이미 거짓을 뜻하는 객체를 리턴함.
    0                     # 이유는 내부적으로 연산량을 줄이기 위해서임. 
    >>> '' and True
    ''
    >>> False and True    # 앞의 결과가 거짓이면 뒤의 결과는 확인하지도 않음. 이것도 연산량을 줄이기 위해서.
    False
    
    >>> True and ''        # A가 참이라면 연산의 결과는 B에 달려있다. 이 때 B의 참/거짓을 판별할 필요 X
    ''                     # 파이썬은 그냥 B의 결과를 리턴한다. 
    >>> True and 1+2+3
    6
    
    >>> result = 1 + 3 - 3 and '값은 0이 아닙니다.'  ## 여긴 이해가 안간다. 
    >>> result                     ## 앞을 판별하기 위해서 한 번 더 입력을 받는 것 같은데 
    '결과 값은 0이 아닙니다.'          ## 왜 1을 넣으면 1이 나올까?(터미널)
                                 ## result를 입력하는게 뭘 뜻하는 걸까? 
      ## 아.... 그냥 할당하는 거였구나.. result 부분도 표현식이라고 생각했다..
    ```

  - `A or B`

    ```python
    >>> 1 or ''         # A가 참이라면 B를 신경쓰지 않고 A를 리턴한다. 
    ''
    >>> False or 'False'  # A가 거짓이라면 or 연산자는 B를 신경도 안씀. 그냥 B를 리턴함. 
    'False'
    ```

  - `not A`  결과값은 항상 True, False 객체이다.

    ```python
    >>> not 0
    True
    >>> not 1
    False
    ```

    
### 5. 형 변환(Typecasting)
- 파이썬에서 데이터 형태는 서로 변환할 수 있음
  - 암시적 형 변환(implicit) : 사용자가 의도하지 않고, 파이썬 내부적으로 자료형을 변환하는 경우
  - 명시적 형 변환(explicit) : 사용자가 특정 함수를 활용하여 의도적으로 자료형을 변환하는 경우 

### 6. 컨테이너
- 여러 개의 값을 담을 수 있는 것(객체)로, 서로 다른 자료형을 저장할 수 있음 ex)list, tuple

- 컨테이너의 분류
  - 순서가 있는 데이터 vs 순서가 없는 데이터
     순서가 있다 = 정렬되어 있다.(index로 접근가능하다라는 것 같다. )
  - 시퀀스
    - 문자열(immutable) : 문자들의 나열
    - 리스트(mutable) : 변경 가능한 값들의 나열
    - 튜플(immutable) : 변경 불가능한 값들의 나열
    - 레인지(immutable) : 숫자의 나열
  - 컬렉션/비시퀀스
    - 세트(mutable) : 유일한 값들의 모음
    - 딕셔너리(mutable) : 키-값들의 모음  
  
- 시퀀스형 주요 공통 연산자

  | 연산                  | 결과                                                         |
  | --------------------- | ------------------------------------------------------------ |
  | s[i:j:k]              | s의 i 에서 j 까지 스텝 k의 슬라이스                          |
  | s + t                 | s 와 t의 이어 붙이기                                         |
  | s * n 또는            | s를 그 자신에 n 번 더하는 것                                 |
  | x in s <-> x not in s | s 의 항목 중 하나가 x 와 같으면 True, 그렇지 않으면 False <-> |
  | len(s)                | s 의 길이                                                    |
  | min(s), max(s)        | s 의 가장 작은 항목, s 의 가장 큰 항목                       |

#### 6.1.1 리스트
- list = [a, 13, ...]
- 순서를 가지며, 서로 다른 타입의 요소를 가질 수 있음
- 대괄호 혹은 list()를 통해 생성(형 변환)
- 순서가 있는 시퀀스로 인덱스를 통해 접근 가능 ex) list[-1]
  ```python
  my_list = [1, 2, 3]
  type(my_list) # <class 'list'>
  my_list.append(4)  # 값 추가
  my_list  # [1, 2, 3, 4]
  my_list.pop(0) # [2, 3, 4]
  ```
  
#### 6.1.2 튜플
- 순서를 가지며, 서로 다른 타입의 요소를 가질 수 있음
- 변경 불가능하며, 반복 가능함
- 소괄호로 생성
  ```python
  my_tuple = (1, 2, 3)
  type(my_tuple)  # <class 'tuple'>
  my_tuple.append(4) #'tuple' object has no attribute 'append'
  ```
#### 6.1.3 레인지
- 숫자의 시퀀스를 나타내기 위해 사용
- range(n, m, s) : n부터 m-1까지 s만큼 증가시키는 숫자의 시퀀스
- 변경 불가능하며, 반복 가능함
  ```python
  range(4)  # range(0, 4)
  list(range(4))  # [0, 1, 2, 3]
  type(range(4))  # <class 'range'>
#### 6.2.1 세트
- 유일한 값들의 모음
- 순서가 없고 중복된 값이 없음. 수학에서의 집합과 동일한 구조를 가지며, 집합 연산도 가능
- 변경 가능하며, 반복 가능함. 단 세트는 순서가 없어 반복의 결과가 정의한 순서와 다를 수 있음
- 중괄호 또는 set()을 통해 생성
- 순서가 없어서 별도의 값에 접근할 수 없다.
- 세트를 활용하면 다른 컨테이너엥서 중복된 값을 쉽게 제거할 수 있음. 단 순서가 무시됨.
- ```python
  numbers = {1, 2, 3}
  numbers.add(5)  # {1, 2, 3, 5}
  numbers.remove(1) # {2, 3, 5}
  ```
#### 6.2.2 딕셔너리
- 키-값 쌍으로 이뤄진 모음
  - 키 : 불변 자료형만 가능(리스트, 딕셔너리 등은 불가능함)
  - 값 : 어떠한 형태든 관계 없음
- 키와 값은 ' : ' 로 구분되고, 개별 요소는 ' , ' 로 구분됨
- 변경 가능하며, 반복 가능함. 
  ```python
  movie = {
      'title' : '설국열차'
      'genre' : ['SF', '액션', '드라마']
      'open_date' : '2013-08-01',
      'time' : 126
      'adult' : False,
  }
  students = {'홍길동' : 100, '김철수' : 90}
  students['홍길동'] = 80  # {'홍길동' : 80, '김철수' : 90}   수정
  students['박영희'] = 95  # {'홍길동' : 80, '김철수' : 90, '박영희' : 95}   추가
  students.pop('홍길동')  #{'김철수' : 90, '박영희' : 95}   삭제
  ```

---


- https://wikidocs.net/20457
- 강의 자료